#第三章页表

页表是操作系统为每个进程提供自己的私有地址空间和物理内存映射的机制（逻辑视图是一个简单的PTE数组）

提供了对于物理内存的复用与虚拟、和对内存的共享

## 3.1 页式硬件

内核指令也是用的虚拟地址

XV6只使用64位虚拟地址的低39位

每个PTE包含一个44位的物理页码（PPN）和一些标志（10位）

###转换机制

页式硬件通过使用虚拟地址39位中的前27位索引页表，找到对应的一个pte，然后生成一个56位的物理地址，其前44位来自PTE中的PPN，其后12位来自原始虚拟地址，所以一个PTE管理4096字节。称为物理块或页面。![img](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p1.png)

实际的转换是三维页表、一级页表（共512个页表项）放在一个页面（sapt寄存器指示）中、依次由虚拟地址的9位来索引![img](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p2.png)

只要虚拟地址确定，那么在页表中的条目也是确定的

###标志位

`PTE_V`指示PTE是否存在：如果它没有被设置，对页面的引用会导致异常（即不允许）。`PTE_R`控制是否允许指令读取到页面。`PTE_W`控制是否允许指令写入到页面。`PTE_X`控制CPU是否可以将页面内容解释为指令并执行它们。`PTE_U`控制用户模式下的指令是否被允许访问页面；如果没有设置`PTE_U`，PTE只能在管理模式下使用（内核场景）

### satp

CSR指示一级页表的物理地址，每个CPU都有自己的`satp`。这样不同的CPU就可以运行不同的进程

## 3.2 内核地址空间

Xv6为每个进程维护一个页表，用以描述每个进程的用户地址空间，外加一个单独描述内核地址空间的页表。

![img](https://pic4.zhimg.com/80/v2-b3cb5245f66563d1fdf844b19f509dab_720w.jpg)

左侧是内核的虚拟地址、右侧是物理内存布局

###物理内存布局

QEMU仿真的RAM，将从物理地址0x80000000（**KERNBASE**）开始，至少到0x86400000为止（**PHYSTOP**，在kernel/memlayout.h中定义其值为0x88000000，所以xv6的RAM实际大小为128M）。QEMU同样也仿真了一些I/O设备，这些设备接口通过**内存映射**的方式，将设备的**控制寄存器**映射到物理内存中，位于KERNBASE下。内核只要读出或写入这些特殊的物理地址，就能直接读写设备的控制寄存器，从而直接地与设备进行通信。

所以在右侧所示的物理内存布局中、只有从KERNBASE到PHYSTOP才对应真正的**DRAM芯片**。位于PHYSTOP上方，可以通过放置新的DRAM芯片来使用、位于KERNBASE下方，访问相应的物理地址，实际上是直接访问相关I/O设备的控制寄存器，而不是访问DRAM芯片。

###内核的直接映射

在内核未启用页表的时候，访问RAM以及经过内存映射的设备控制寄存器时，内核的虚拟地址将采用**直接映射**的方式进行转换，即虚拟地址与实际物理地址相同。这种直接映射，也会在初始化内核页表的过程中（kernel/vm.c的kvminit），记录到内核页表中，即使内核开始使用页表，这种直接映射的布局也被保留了下来。

大部分都是比如说内存和内存映射设备寄存器。

内核的虚拟地址空间中，也有一些部分**不仅仅使用直接映射**。上图的左半部分展示了，除了直接映射之外，还有一些额外的布局与设置，它们位于内核虚拟地址空间的顶部，在初始化了内核页表，并且启用页表之后，就可以正式使用这些布局设置。

一是**trampoline**页，它被映射到内核虚拟地址空间的顶端（一次直接映射，一次在顶部）

二是**内核栈**，

个进程都对应一个内核栈。更准确地说，每个进程在用户空间执行指令时使用的是用户栈，而在内核空间下执行时（一般称为这个用户进程的内核线程）使用的是内核栈

还有对应的保护页，防止一个进程的内核栈破坏另一个进程

有内核进程吗？内核地址空间

##**vm.c**

与虚拟内存相关的代码

核心的数据结构是pagetable_t，它是uint64*类型，指向存放RISC-V根页表的一页。

核心的函数是walk和mappages。

walk为给定的虚拟地址，找到其相应的PTE，如果PTE不存在则新分配一页使之有效，它**模仿**的是真实分页硬件查找页表的过程，可以看成是查找页表MMU的**软件实现**，在内核或进程的页表未初始化时，内核就用它来转换相关虚拟地址；

mappages为给定输入的映射建立PTE，更新页表。

kvm开头的函数对内核页表进行操作，uvm开头的函数对用户页表进行操作，copyout和copyin完成内核空间和用户空间之间的数据复制

内核启动阶段，**main**（kernel/main.c）将调用**kvminit**创建内核页表，其中先kalloc分配一个物理页面来放置根页表，然后用kvmmap来建立直接映射，给trampoline建立间接映射（这里就是在虚拟地址的最高位$2^{39}-1$，其实在前面的物理内存映射中以及映射过一次了），最后调用proc_mapstacks（）来为内核虚拟地址空间的高位仅仅低于trampoline，放置每一个进程的内核栈和保护页（并）。最后kvminithart来启动分页，时刻记住这之前物理地址=虚拟地址，此后的机器才真正用上了分页这一机制。从此接触到的地址，变量名都是虚拟的地址了。只有要手动改变，因此walk和mappages的主要作用还是主动的设置页表，为用户，虚拟地址空间定调。因为前面提到过的直接映射，所以在内核中使用虚拟地址也就是使用物理地址，所以，先前声明的所有全局变量都可以用，这也是直接映射的必要性



### walk

依次走三级页表、若三级页表有一级有效位为零，则分配对应的一页物理帧，清空为零，再把对应的地址放到页表中，并不分配最后的物理页。

返回回最后一级的pte、但是不给物理页分配空间。因此返回的pte的值全是0.

walkaddr返回va对应的pa

### mappages

将pa的size以页为单位映射到va

返回walk得到最后以及pte，然后用ppn填充这一个pte，此时正式在虚拟空间存在了这一个地址

kvmmap只是对mappages加上了错误检测

kvminithart将satp寄存器中更新为内核的页表，并且刷新TLB

##3.4 物理内存分配

内核要为页表、用户内存、内核栈和管道缓冲区分配和释放物理内存。

xv6用end到`PHYSTOP`之间的物理内存来分配，使用链表的形式来管理、并以此方式来记录空闲的物理帧

## kalloc.c

核心的是kalloc和kfree

main调用kinit来获得初始化所有可用的物理帧（end-PHYSTOP）

### kfree

有一个kmem的数据结构，指示其中的freelist

将pa对应的物理帧（这个pa要字节对齐才行）通过头插法插入freelist中

### kalloc

从freelist获取到第一个物理帧，然后再摘下来

freerange就是从start到end的所有地址对齐来kfree

## 3.6用户的虚拟地址空间

每个用户进程都有自己的页表，因此也有不同的虚拟地址空间。

用户进程的虚拟地址空间同样从0开始，一直到MAXVA。

一个用户进程如果在运行时需要额外内存，就向内核内存分配器发出请求，让kalloc分配一些物理页然后内核会更新用户进程的页表，设置新的PTE（此前提到的5个标志位都被设置）。进程中间那些未使用的虚拟地址，只需要在页表中将相关的PTE标记为无效即可。

![img](https://pic4.zhimg.com/80/v2-720255f646521dbb0fa067a89b21044f_1440w.jpg)

为了防止用户栈溢出，在栈的下面也放置了一页保护页。这里的保护页是**有实际的物理帧**对应的标志位为RWV，没有U）。然后是user text和data，xv6为了简单起见，将它们放在了同一页内。

## sbrk也即vm中的user函数，以及proc.c的内存部分

main调用procinit（）来分配其kstack的值来得到内核栈，userinit来创建第一个init进程时，会再里面调用allocproc（），找到一个unused的进程，分配pid号，更新stste，然后调用proc_pagetable设置pagetable，然后调用uvminit分配一个物理页面，将initcode复制过来，将虚拟地址0映射到这个页面，而后返回，再之后设置进程的pc为前面的0，sp为PGSIZE（也就是说栈顶就在4096，并且向下生长（也太小了））p的sz设置为4096向上生长，最后返回，调用了schedule之后即可启动进程

### sbrk

用于进程减少或增长其内存的系统调用，取出要申请的内存大小后，就调用growproc来分配

### growproc

如果n是正的，则uvmalloc否则uvmdealloc取消分配，这两个函数都是从sz到sz+n的虚拟地址来分配的，

### uvmalloc

反复的以页面为单位kalloc一个物理页面来，再通过mappages修改页表来映射过去，如果失败则调用uvmdealloc
### uvmdealloc

如果old在new的上面的话，就uvmunmap从new到old的所有页面

### uvmunmap

从最后一级页表中删除对于va的映射，还会视do_free情况free掉对应的物理内存

### uvmfree

把从0到sz的内存全部删除映射，并且还要free掉这个物理内存，然后再通过freewalk递归地删除掉这个从一级到三级所有的页表。

### proc_pagetable

掉用uvmcreate产生一个根页表，使用mappages来为用户的根页表设置TRAMPOLINE、TRAPFRAME（都在虚拟地址的最高位）（注意用户的虚拟地址空间不会有内核栈），

### uvmcreate

kalloc分配一个物理帧来充当一个根页表，（也就是创建一个内核的虚拟地址空间），并返回这个根页表的地址

### uvminit

从虚拟地址0开始的一个页面大小映射到一个物理帧上面，然后将src的内容复制过去（主要用于initcode）

## exec

作用是将path的文件装载到自己这个进程上面

通过argstr从0取出到path去，再从1取argv的地址到uargv,uargv是一个指针的数组（里面是虚拟的地址），然后依次调用fetchaddr从uargv里面取出地址到uarg，然后再调用fetchstr从uarg取出实际的字符串到argv，这里注意，argv应该有地址才行，所以要kalloc才可以使用

终于进入本体exec，首先调用namei来搜索path，再调用readi来把elf头给导入了，然后调用一个proc_pagetable来创建一个根页表，然后根据elf的节偏移字段phoff来索引到段表，再用uvmalloc来为这个段分配空间，并更新页表，再通过loadseg，用walkaddr将虚拟地址转为物理地址，再通过readi导入，这之后，data和text节的数据都导入了，再分配两个页面，其中一个做保护页，另一个做栈，然后将命令行参数的字符串、指向这些命令行参数的指针数组argv[ ]、用于从调用main(argc, argv[ ])返回的其它参数（argc、argv指针和伪造的返回pc值）推入用户栈，和ustack内。ustack通过栈来返回，argc通过a0给main，最后设置pcb的一系列值，最后再把原来的页表给free掉即可

还有栈不太明白，其他都还好了

### fetchaddr

主要是调用copyin从虚拟地址中取出对应的值，只是检测了一下，这个地址addr是不是在sz以上的部分

### copyin

将srcva通过walkaddr转换成物理地址，然后再从这个物理地址memmove到dst中

### argstr

调用argaddr取出地址（c中字符串以字符数组形式存在，必然是用户的虚拟地址，但是是内核在调用，所以要处理好这个内核读用户虚拟地址的问题）再fetchstr从这个地址中取出字符串到buf中，返回字符串长度

### fetchstr

主要是调用copyinstr，只是多了差错检测，并且多返回了一个字符串长度

### copyinstr

从srcva先转成物理地址，但是walkaddr需要是对齐的，所以还要先对齐，然后将这个物理地址依次复制到dst中，最多就是一个页面这么大，



将





sys_exec主要是，取出path和argv然后调用exec





##calling Convention

 

| **C数据类型** | **描述**       | **RV32中字节数** | **RV64中字节数** |
| ------------- | -------------- | ---------------- | ---------------- |
| `char`        | 字符值/字节    | 1                | 1                |
| `short`       | 短整型         | 2                | 2                |
| `int`         | 整型           | 4                | 4                |
| `long`        | 长整型         | 4                | 8                |
| `long long`   | 超长整型       | 8                | 8                |
| `void*`       | 指针           | 4                | 8                |
| `float`       | 单精度浮点型   | 4                | 4                |
| `double`      | 双精度浮点型   | 8                | 8                |
| `long double` | 扩展精度浮点型 | 16               | 16               |

除了32位的int其他的低于寄存器位数的，有符号数以符号扩展的形式存在，无符号则以零扩展存在。而int不管有无符号都是符号扩展

当函数的参数传递c结构体时，是按值传递的（不是传递指针！！！），基本方法是参数寄存器是该结构体中前八个指针字长参数的副本，当在堆栈上传递两倍于指针字大小的基本参数时，它们是自然对齐的。当它们在整数寄存器中传递时，它们驻留在对齐的偶数号-奇数号寄存器对中，偶数寄存器保存最低有效位。大于指针字大小两倍的参数通过引用传递。（地址）

栈向下增长，栈指针始终保持16字节对齐。





