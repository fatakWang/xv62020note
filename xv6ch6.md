# 锁locking

并发（concurrency）是指由于多处理器并行、线程切换或中断，多个指令流交错的情况

## 竞争条件

竞态条件是指多个进程读写某些共享数据（至少有一个访问是写入）的情况。

锁确保互斥，这样一次只有一个CPU访问临界资源。

临界区是指一段可能改变公共资源的代码，可以被`acquire`和`release`包起来，实现互斥确保串行化调度。

## LOCKS

Xv6有两种类型的锁：自旋锁（spinlocks）和睡眠锁（sleep-locks）。

自旋即循环等待，自旋锁的实现需要硬件上的原子操作来实现。

在正式忙等待前，先要push_off关中断（主要是防止中断处理程序搞乱），检测此进程之前是否或取该锁，然后才是testandset，将lk->locked与1交换，返回lk->locked的旧值。

然后在设置cpu，

realse与之相反

### 使用锁

大内核锁，即所有进程进入内核先要获得锁，一次只能有一个CPU运行在内核中。

粗粒度锁，即获得资源必须上锁，细粒度锁对资源每个部分区分的来上锁

xv6中的所有锁

| **锁**                | **描述**                                               |
| --------------------- | ------------------------------------------------------ |
| `bcache.lock`         | 保护块缓冲区缓存项（block buffer cache entries）的分配 |
| `cons.lock`           | 串行化对控制台硬件的访问，避免混合输出                 |
| `ftable.lock`         | 串行化文件表中文件结构体的分配                         |
| `icache.lock`         | 保护索引结点缓存项（inode cache entries）的分配        |
| `vdisk_lock`          | 串行化对磁盘硬件和DMA描述符队列的访问                  |
| `kmem.lock`           | 串行化内存分配                                         |
| `log.lock`            | 串行化事务日志操作                                     |
| 管道的`pi->lock`      | 串行化每个管道的操作                                   |
| `pid_lock`            | 串行化next_pid的增量                                   |
| 进程的`p->lock`       | 串行化进程状态的改变                                   |
| `tickslock`           | 串行化时钟计数操作                                     |
| 索引结点的 `ip->lock` | 串行化索引结点及其内容的操作                           |
| 缓冲区的`b->lock`     | 串行化每个块缓冲区的操作                               |

### 死锁和锁排序

所有代码路径以相同的顺序获取锁可以有效避免死锁。xv6的内核实现须以一种使锁按照约定顺序被获取的方式调用函数。

比如在**consoleintr**中，先获取了cons.lock后获取了进程锁，那么以后只要有既要cons.lock又要进程锁的场合，就必须遵循先cons后进程的顺序。

之所以这个顺序很难设计是因为有时锁顺序与逻辑程序结构相冲突。

###锁和中断处理函数（为什么获取锁要关中断）

如果一个锁被中断处理程序所使用，那么CPU必须保证在启用中断的情况下永远不能持有该锁。Xv6更保守：当CPU获取任何锁时不只是acquire，而且是后面所有过程，xv6总是禁用该CPU上的中断。

`acquire`调用`push_off`,并且`release`调用`pop_off`,来跟踪当前CPU上锁的嵌套级别。当计数达到零时，`pop_off`恢复最外层临界区域开始时存在的中断使能状态。`intr_off`和`intr_on`函数执行RISC-V指令分别用来禁用和启用中断。

疑问：如果只有一个cpu的话，那么关闭中断了，会不会导致死锁？

首先计时器中断在任何情况下都不会禁用，计时器中断是发出了软件中断，但是软件中断会被屏蔽掉。

看错了，acquire并没有pop_off

### 指令和内存访问排序

编译器和cpu为了获得更高的性能而不按顺序执行代码。但有些代码必须是串行的，编译器和CPU在重新排序时需要遵循一定规则以确保正确结果。CPU的排序规则称为内存模型（memory model）。

`__sync_synchronize()`是一个内存障碍：它告诉编译器和CPU不要跨障碍重新排序`load`或`store`指令。

### 睡眠锁

自旋锁的另一个缺点是，一个进程在持有自旋锁的同时不能让出（yield）CPU，导致资源的浪费

持有自旋锁时不能让步：

1. 可能导致死锁：就是我之前担心的，第二个线程的自旋可能会阻止第一个线程运行并释放锁。
2. 也违反了在持有自旋锁时中断必须关闭的要求。

Xv6以睡眠锁（sleep-locks）的形式提供了一种锁，它在等待获取锁时让出CPU，并允许在持有锁时让步（以及中断）。

睡眠锁有一个被自旋锁保护的锁定字段，`acquiresleep`对`sleep`的调用原子地让出CPU并释放自旋锁

睡眠锁保持中断使能，所以它们不能用在中断处理程序（不要被其他中断给中断了）中。因为`acquiresleep`可能会让出CPU，所以睡眠锁不能在自旋锁临界区域中使用（尽管自旋锁可以在睡眠锁临界区域中使用）。

自旋锁最适合短的临界区域；睡眠锁对于冗长的操作效果很好。
