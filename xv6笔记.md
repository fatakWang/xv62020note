# seq 8

##一、操作系统接口
#### 操作系统的工作

1. 给程序提供一系列比硬件本身更有用的服务
2. 管理并抽象底层硬件
3. 多路复用硬件，使得同一时间运行多个进程
4. 使得多个进程协作在一起

操作系统通过接口向用户程序提供服务，接口的设计依赖于少量的机制 （mechanism）

xv6也提供了像unix一样简单而有效的接口

xv6也使用了经典的单内核，多进程模型，

内核（a special program that provides services to running programs）

进程has memory containing instructions, data, and a stack. 

process invokes a system call to access kernel service

kernel 有硬件级的机制来访问任何空间、process 不行

#### 进程和内存

xv6的进程由用户空间内存(指令、数据和堆栈)和对内核私有的每个进程状态组成。

#####fork

在父进程中，fork返回子类的PID；在子进程中，fork返回零。

#####`exit`

导致调用进程停止执行并释放资源（如内存和打开的文件）。0成功、1失败

#####`wait`

返回当前进程的已退出(或已杀死)子进程的PID，并将子进程的退出状态复制到传递给`wait`的地址

如果调用方的子进程都没有退出，那么wait等待一个子进程退出。

如果调用者没有子级，`wait`立即返回-1。

如果父进程不关心子进程的退出状态，它可以传递一个0地址给`wait`。

进程之间的内存空间相互独立

#####`exec`
使用从文件系统中存储的文件所加载的新内存映像替换调用进程的内存。（相对于做了一个加载）

当`exec`执行成功，它不向调用进程返回数据，而是使加载自文件的指令在`ELF header`中声明的程序入口处开始执行。

`exec`有两个参数：可执行文件的文件名和字符串参数数组。字符串参数数组argv的最后一个位要是0，其结构就应该是shell调用的形式

#### 文件描述符

文件描述符是一个小整数（其实是索引），表示进程可以读取或写入的由内核管理的对象。文件描述符是一系列IO的抽象。

件描述符0读取（标准输入即为键盘输入），1（标准输出），2（标准错误）。1、2都是屏幕

`read(fd，buf，n)`从文件描述符fd读取最多n字节，将它们复制到buf，并返回读取的字节数

`write(fd，buf，n)`将buf中的n字节写入文件描述符，并返回写入的字节数

只有发生错误时才会写入小于n字节的数据。

每个文件描述符都有一个与之关联的偏移量。r、w都从这个偏移量开始。

系统调用`exec`替换了调用进程的内存，但保留其文件表。

每次新开一个文件都会用最小的可用的文件描述符（以此实现文件重定向>或者<）

`open`的第二个参数用于控制打开的操作。（可读可写等）

`dup`系统调用复制一个现有的文件描述符，返回一个引用自同一个底层I/O对象的新文件描述符，两个文件描述符共享一个偏移量。

#### 管道

管道是作为一对文件描述符公开给进程的小型内核缓冲区，一个用于读取，一个用于写入(双向通信

)。

#####`pipe（int p[2]）`

从p[0]读，从p【1】写，半双工

创建一个新的管道，并在数组p中记录读写文件描述符。

可以用于实现|

####文件系统

Xv6文件系统提供数据文件和目录，这些目录形成一个树，根目录为`/`

最前面有/则为绝对路径，否则为相对路径。

通过`chdir`系统调用进行更改当前工作目录

- `mkdir`创建一个新目录
- `open`中若使用`O_CREATE`标志将会创建一个新的数据文件
- `mknod`创建一个新的设备文件

一个文件的名字和文件本身是不同的；一个文件由inode标识，可以有多个link（链接）。

每个链接都由目录中的一个条目组成;该条目包含一个文件名和一个inode引用。

Inode保存有关文件的元数据

`fstat`系统调用从文件描述符所引用的inode中检索信息，它填充一个`stat`类型的结构体。

`link`系统调用创建另一个文件名，该文件名指向与现有文件相同的inode。

`unlink`系统调用从文件系统中删除一个名称。只有当文件的链接数为零且没有文件描述符引用时，文件的inode和包含其内容的磁盘空间才会被释放。

#### 真实世界

Unix系统调用接口已经通过便携式操作系统接口(POSIX)标准进行了标准化

一切皆文件
